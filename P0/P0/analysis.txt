
1. Task 1 consists of finding how many different numbers are in the records.

While there are two for loops in the solution, the overall operation results in iterating over every single record of calls and texts. This results is a O(n) operation and for each telephone number the update set operation is performed, using a python set to keep track of unique numbers. The update set will consist of a lookup operation (x in s) to determine if the current number is already present in the set. If is not part of the set then an addition operation is performed to include in the set. A python set is implemented as a hash table, where addition has a constant time complexity O(1) and the lookup operation has an average complexity of O(1) and a worst case complexity of O(n). Therefore, the time complexity of the solution will be O(n*1*1) simplified as O(n) for its average case where both a lookup and addition is performed, and O(n^2) for worst case complexity where the lookup resulted in O(n) do to high load factor.

2. Task2 consists of finding the number that spent the longest time on the phone.

We iterate over every calls record which contain two telephone numbers, so we can use the same definition for the inputs n to be equal to the total number of telephone numbers in the records. The solution uses a dictionary using numbers as keys and the duration as their value. For each number in the records we perform the update dict operation that consist of a lookup (n in d) and a set or set-get operation if the element is already in the dictionary. These operations have constant time complexity of O(1) for their average case, with the lookup operation having a worst case of O(n) if load factor is high and the set-get an amortized worst case of O(n) individually. Since these are rare conditions and will not be impacted in the current use case the total time complexity can be defined as O(n*1*1) or O(n), but true worst case on lookup woudl result in a time complexity of O(n^2).

3. Task 3 consists of identifying the codes for numbers called by people in Bangalore, and then determine the percentage of calls between Bangalore numbers.

To determine the outgoing calls from Bangalore numbers we iterate over all calls records which can be defined as n. The calls are then processed to find unique prefixes since we are iterating again over the records, the worst case would be a set of records with all the calls being outgoing calls from Bangalore resulting in O(2n) ignoring the additional operations. For each of these records, the area code is parsed for each of the types of area codes. Since we know each telephone number length is 10 it would only account for a worst case of O(30) lookup complexity. The update set operation has constant time O(1). Finally sorting has a time complexity of O(nlogn). The final worst case time complexity would then be O(n+n*30+nlogn) or O((31+logn)*n).

The percentage calculation iterates over the calls once and has therefore O(n) complexity

4. Task 4 consists of identifying possible telemarketers
A mechanical approach to solve this problem would involve getting the outgoing unique numbers from the calls records, a big O(n) operation and then checking if it appears in incoming calls, sent texts, or received texts record  which is a worst case O(n). This could mean a worst case complexity O(n^2).

My solution uses python sets operations since we know we only want to know numbers in the outgoing calls set that are not part of the incoming calls, sent texts, and received texts. Generating the sets is a O(n) operation since we traverse all the records, with additional constant time overhead from lookup and addition to the set which are average O(1) operations plus checking if the call has the telemarketer prefix already which is constant since string length is 10. The difference operation of two sets (s-t) is O(len(s)), and since this is done three times the worst case complexity would be O(3n). Both operations would then account result in a combined complexity of O(n+3n) or O(4n). Sorting them then results in an additional O(nlogn) operation for a combined complexity of O((4+logn)*n).
